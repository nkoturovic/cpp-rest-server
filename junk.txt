/* Bellow are functions that operate on constraints 
 * these functions could have been member functions,
 * but this way is more modular */

// WRAP FOR HANA MAYBE ??????
// auto wrap_for_hana(auto &&f) {
//     return [&f](auto x) {
//          using T = typename decltype(x)::type;
//          return f.template operator()<T>();
//     };
// }
// 
// auto tf = hana::transform(x.username.cnstr_list, cnstr::wrap_for_hana(cnstr::description));
//     hana::for_each(tf, [](auto x) {
//         std::cout << x << '\n';
//     });

//template <Cnstr C>
//constexpr auto name() -> const char * {
//constexpr auto name = []<Cnstr C>() -> const char * {
//    if constexpr (std::is_same_v<NotEmpty, C>) {
//        return "NotEmpty";
//    } else if constexpr (is_specialization_num<C, Length>::value) {
//        return "Length";
//    } else if constexpr (is_specialization_num<C, Between>::value) {
//        return "Between";
//    } else if constexpr (std::is_same_v<Required, C>) {
//        return "Required";
//    } else {
//        return "Other";
//    }
//};
//




#include <cstddef>
#include <type_traits>
#include <tuple>

namespace rs {

template <typename... Ts>
struct print_types;

template<typename T> 
struct function_traits;  

template<typename R, typename ...Args> 
struct function_traits<R(*)(Args...)>
{
    static const size_t nargs = sizeof...(Args);
    using result_type = R;

    template <size_t i>
    struct arg
    {
        using type = typename std::tuple_element<i, std::tuple<Args...>>::type;
    };
};


template <typename Tp, typename... List >
struct contains : std::true_type {};

template <typename Tp, typename Head, typename... Rest >
struct contains<Tp, Head, Rest...>
: std::conditional< std::is_same<Tp, Head>::value,
    std::true_type,
    contains<Tp, Rest...> >::type {};

template <typename Tp >
struct contains<Tp> : std::false_type {};



template<class T, template<class...> class Template>
struct is_specialization : std::false_type {};

template<template<class...> class Template, class... Args>
struct is_specialization<Template<Args...>, Template> : std::true_type {};

template<typename Test, template<size_t ...> class Ref>
struct is_specialization_num : std::false_type {};

template<template<size_t...> class Ref, size_t... Args>
struct is_specialization_num<Ref<Args...>, Ref> : std::true_type {};

}


